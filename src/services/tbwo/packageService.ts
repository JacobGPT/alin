import type { TBWO, TBWOReceipts, Artifact } from '../../types/tbwo';

interface PackageManifest {
  name: string;
  version: string;
  createdAt: string;
  tbwoId: string;
  tbwoType: string;
  qualityTarget: string;
  files: Array<{ path: string; size: number; type: string }>;
  summary: string;
  totalSize: number;
}

interface DownloadPackage {
  manifest: PackageManifest;
  files: Map<string, string>; // path -> content
  receipt?: TBWOReceipts;
}

export class PackageService {
  // Build downloadable package from TBWO results
  buildPackage(
    tbwo: TBWO,
    artifacts: Artifact[],
    receipts?: TBWOReceipts
  ): DownloadPackage {
    const files = new Map<string, string>();
    const fileManifest: PackageManifest['files'] = [];

    for (const artifact of artifacts) {
      if (!artifact.path || typeof artifact.content !== 'string') continue;
      files.set(artifact.path, artifact.content);
      fileManifest.push({
        path: artifact.path,
        size: artifact.content.length,
        type: artifact.type,
      });
    }

    // Add receipt as README
    if (receipts?.executive) {
      const readme = this.buildReadme(tbwo, receipts);
      files.set('README.md', readme);
      fileManifest.push({
        path: 'README.md',
        size: readme.length,
        type: 'document',
      });
    }

    const totalSize = Array.from(files.values()).reduce(
      (sum, content) => sum + content.length,
      0
    );

    const manifest: PackageManifest = {
      name: tbwo.objective
        .slice(0, 50)
        .replace(/[^a-zA-Z0-9\s-]/g, '')
        .trim()
        .replace(/\s+/g, '-')
        .toLowerCase(),
      version: '1.0.0',
      createdAt: new Date().toISOString(),
      tbwoId: tbwo.id,
      tbwoType: tbwo.type,
      qualityTarget: tbwo.qualityTarget,
      files: fileManifest,
      summary: receipts?.executive?.summary || tbwo.objective,
      totalSize,
    };

    return { manifest, files, receipt: receipts };
  }

  // Export as downloadable zip-like blob (JSON archive since we can't use JSZip without deps)
  exportAsJSON(pkg: DownloadPackage): string {
    const exportData = {
      manifest: pkg.manifest,
      files: Object.fromEntries(pkg.files),
      receipt: pkg.receipt
        ? {
            executive: pkg.receipt.executive,
            technical: pkg.receipt.technical,
          }
        : undefined,
    };
    return JSON.stringify(exportData, null, 2);
  }

  // Trigger browser download
  downloadPackage(pkg: DownloadPackage): void {
    const json = this.exportAsJSON(pkg);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${pkg.manifest.name}.alin-package.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Build README from receipts
  private buildReadme(tbwo: TBWO, receipts: TBWOReceipts): string {
    const exec = receipts.executive;
    const tech = receipts.technical;

    return `# ${tbwo.objective}

> Built with ALIN TBWO Engine

## Summary
${exec.summary}

## Accomplishments
${exec.accomplishments.map((a) => `- ${a}`).join('\n')}

${
  exec.unfinishedItems.length > 0
    ? `## Known Limitations
${exec.unfinishedItems.map((i) => `- ${i}`).join('\n')}`
    : ''
}

## Quality
- Overall Score: ${exec.qualityScore}/100
- Build Status: ${tech.buildStatus}
- Files Created: ${exec.filesCreated}
- Lines of Code: ${exec.linesOfCode}

## Technical Details
${
  tech.dependencies.length > 0
    ? `### Dependencies
${tech.dependencies.map((d) => `- ${d.name}@${d.version}`).join('\n')}`
    : ''
}

---
*Generated by ALIN TBWO Engine on ${new Date().toLocaleDateString()}*
`;
  }
}

export const packageService = new PackageService();

/**
 * TBWO ZIP Service â€” builds in-memory ZIP from tbwo.artifacts[]
 *
 * All TBWO output is stored in artifacts (content + path).
 * This service packages them into a downloadable ZIP without
 * ever touching the filesystem.
 */

import JSZip from 'jszip';
import { downloadBlob } from '../../utils/cn';
import type { TBWO, TBWOReceipts } from '../../types/tbwo';

/**
 * Count artifacts that have downloadable file content.
 */
export function countDownloadableArtifacts(tbwo: TBWO): number {
  return (tbwo.artifacts || []).filter(
    (a) => typeof a.content === 'string' && a.content.length > 0 && a.path
  ).length;
}

/**
 * Build a ZIP Blob from a TBWO's artifacts.
 * Strips the `output/tbwo/<slug>/` prefix so the ZIP root is clean.
 * Optionally includes a generated README.md from receipts.
 */
export async function buildTBWOZip(
  tbwo: TBWO,
  receipts?: TBWOReceipts | null
): Promise<Blob> {
  const zip = new JSZip();

  // Compute the common prefix to strip (e.g. "output/tbwo/my-project/")
  const slug = tbwo.objective
    ? tbwo.objective.toLowerCase().replace(/[^a-z0-9]+/g, '-').slice(0, 40)
    : tbwo.id;
  const prefixToStrip = `output/tbwo/${slug}/`;

  for (const artifact of tbwo.artifacts || []) {
    if (typeof artifact.content !== 'string' || !artifact.content || !artifact.path) {
      continue;
    }

    let filePath = artifact.path;
    // Strip the output/tbwo/<slug>/ prefix for a cleaner ZIP
    if (filePath.startsWith(prefixToStrip)) {
      filePath = filePath.slice(prefixToStrip.length);
    } else if (filePath.startsWith('output/tbwo/')) {
      // Strip any output/tbwo/*/ prefix
      const afterTbwo = filePath.slice('output/tbwo/'.length);
      const slashIdx = afterTbwo.indexOf('/');
      filePath = slashIdx >= 0 ? afterTbwo.slice(slashIdx + 1) : afterTbwo;
    } else if (filePath.startsWith('output/')) {
      filePath = filePath.slice('output/'.length);
    }

    // Avoid empty paths
    if (!filePath) filePath = artifact.name || 'file.txt';

    zip.file(filePath, artifact.content);
  }

  // Generate a README.md from receipts if available
  const readme = buildReadme(tbwo, receipts);
  if (readme) {
    zip.file('README.md', readme);
  }

  return zip.generateAsync({ type: 'blob' });
}

/**
 * Build and trigger browser download of the TBWO ZIP.
 */
export async function downloadTBWOZip(
  tbwo: TBWO,
  receipts?: TBWOReceipts | null
): Promise<void> {
  const blob = await buildTBWOZip(tbwo, receipts);
  // Prefer productName from brief for cleaner ZIP filenames (e.g. "memorylane-website.zip")
  const briefName = (tbwo.metadata?.siteBrief as Record<string, unknown> | undefined)?.productName as string | undefined;
  const rawName = briefName || tbwo.objective || 'tbwo';
  const safeName = rawName
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 40);
  downloadBlob(blob, `${safeName}-website.zip`);
}

// ---------------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------------

function buildReadme(tbwo: TBWO, receipts?: TBWOReceipts | null): string | null {
  const lines: string[] = [];
  lines.push(`# ${tbwo.objective || 'TBWO Output'}`);
  lines.push('');
  lines.push(`Generated by ALIN TBWO on ${new Date(tbwo.completedAt || tbwo.updatedAt).toLocaleDateString()}`);
  lines.push('');

  if (receipts?.executive) {
    const exec = receipts.executive;
    lines.push('## Summary');
    lines.push(exec.summary || 'No summary available.');
    lines.push('');

    if (exec.accomplishments?.length) {
      lines.push('## Accomplishments');
      for (const a of exec.accomplishments) {
        lines.push(`- ${a}`);
      }
      lines.push('');
    }

    lines.push('## Stats');
    lines.push(`- Files created: ${exec.filesCreated}`);
    lines.push(`- Lines of code: ${exec.linesOfCode}`);
    lines.push(`- Quality score: ${exec.qualityScore}%`);
    lines.push('');
  }

  // List files included in the ZIP
  const fileArtifacts = (tbwo.artifacts || []).filter(
    (a) => typeof a.content === 'string' && a.content.length > 0 && a.path
  );
  if (fileArtifacts.length > 0) {
    lines.push('## Files');
    for (const a of fileArtifacts) {
      lines.push(`- \`${a.path}\``);
    }
    lines.push('');
  }

  return lines.join('\n');
}
